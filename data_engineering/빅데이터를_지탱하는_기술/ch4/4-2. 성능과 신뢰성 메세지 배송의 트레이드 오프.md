클라이언트의 수가 많아지면 스트리밍형의 메세지 배송의 성능과 신뢰성을 둘 다 만족하기 어려워진다.
이와 관련해서 클라이언트와 분산스토리지 사이에서 메세지 전달을 담당하는 메세지 브로커의 구조와 한계에 대해 이해하는 것이 중요하다.

# 메세지 브로커(스토리지 성능 문제를 해결하는 중간층의 설치)
분산 스토리지에 직접적으로 메세지를 배송하면 부하 제어가 힘들기 때문에 그 중간에서 메세지를 받아서 분산 스토리지에 적절하게 전달하는 역할로서 메세지 브로커가 중요하다.
(대표적인 오픈소스로는 kafka, 클라우드로는 kinesis가 있다.)

스트리밍 데이터의 경우 쓰기의 빈도가 점점 증가하고 쓰기가 일어나는 즉시 요청을 보내게 되면 서버에 부하가 발생할 수 있다.
중간에 데이터를 일시적으로 축적하는 중산층이 설치되며 이 것이 메세지 브로커의 역할이다.

메세지 브로커에 데이터를 넣는 것을 생산자(producer) 꺼내오는 것을 소비자(consumer)라고 한다.
메세지 브로커는 높은 빈도로 데이터를 쓰는 것에 최적화되어 있으며, 여러대의 노드에 부하 분산함으로써 성능을 끌어올릴 수 있다.

스트리밍 데이터의 각 용량은 매우 적기 때문에 데이터를 잦은 빈도로 처리하면 부하가 생긴다.
따라서 메세지 브로커에서 적절하게 모아서 한꺼번에 파일에 저장한다.
이렇게 메세지 브로커에 모아진 데이터는 여러 용도로 한꺼번에 활용 가능하며 이를 메세지 라우팅이라고 한다.

# 메세지 배송을 확실하게 실시하는 것은 어렵다(신뢰성 문제와 세가지 설계 방식)
이러한 메세지 배송에서는 신뢰성 문제가 항상 따른다.
따라서 다음 중 하나를 보장하도록 설계된다.
* at most once : 메세지는 한 번만 전송된다. 그러나 메세지 결손 발생 가능성이 있다.
* exactly once : 메세지는 손실되거나 중복없이 한 번만 전달된다.
* at least once : 메세지는 확실히 전달된다. 하지만 중복의 가능성이 있다.

at most once의 경우 장애 감지시 재전송이 발생하면 지켜지기 힘들다. 
말 그대로 장애가 발생하면 메세지를 재전송하기 때문이다.

이를 위해 코디네이터가 존재하여 송수신측 사이를 중계한다.
그러나 코디네이터 또한 통신이 끊길수도 있고, 코디네이터에 전적으로 의존하기에는 효율적이지 않아서 일반적으로는 중복을 전제로 하고 시스템을 구축한다.
즉 성능을 보장하되 신뢰성을 보장하기가 힘들다.

# 중복 제거는 높은 비용의 오퍼레이션
관리자는 중복제거를 위한 구조를 설계해두어야 한다. 보통 통신이 이루어질 때 식별 가능한 시퀀스 번호가 포함되는데 이를 통해 중복제거를 하는 것이다.
그러나 분산 시스템에서는 그닥 사용되지 않는다.

* 오프셋을 이용한 중복제거 : 각 메세지에 파일 안의 시작위치를 덧붙인다. 메세지가 중복되면 같은 파일의 같은 장소를 덮어쓰게 되는 것이다. 이는 벌크형 배치처리에 적당하지만 스트림 처리에는 부적절하다.
* 고유 ID에 의한 중복제거 : 모든 메세지에 UUID 등의 고유 ID를 지정하는 방법이다. 모든 아이디를 기억하는 것은 비현실적이므로 최근에 받은 ID만을 기억하고, 그보다 늦게 온 메세지의 중복은 허용한다.(자료구조 Map을 생각하면 편하다.)
* 차후에 데이터를 읽어들일 때 SQL로 중복 제거

빅 데이터의 메세지 배송은 신뢰성보다는 효율을 중시한다.
따라서 때로는 중복제거를 하지 않기도 한다. 최종적으로 분산 스토리지에 저장되기 직전 최종 과정에서 중복 제거를 하고 저장하거나 분산 스토리지에 저장한 후 열지향 스토리지에 저장할 때 중복제거가 진행된다. 분산 스토리지까지 스트리밍으로 저장하다가 열지향 스토리지로 벌크처리하여 데이터를 구조화 하는 것이다.
메세지 배송 처리에 많은 과정이 있으므로 매 과정마다 중복 제거를 해도 또 어디선가 중복이 발생할 수도 있기 떄문이다.

# 데이터 수집의 파이프라인(장기적인 데이터 분석에 적합한 스토리지)
기본적으로 중복을 고려하여 시스템을 설계해야 한다. 즉 멱등성을 고려하자.
